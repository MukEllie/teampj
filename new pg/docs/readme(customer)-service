# 게임 포털 고객센터 시스템 README

## 📋 프로젝트 개요

게임 포털 웹사이트의 고객센터 기능을 구현한 시스템입니다. 사용자 문의 처리, 실시간 채팅, FAQ 관리 등의 기능을 제공합니다.

## 🏗️ 파일 구조

```
customer-service/
├── customer-service.html    # 고객센터 메인 페이지
├── customer-service.js      # 고객센터 전용 JavaScript
├── styles.css              # 스타일시트 (별도 파일)
└── common-auth.js           # 공통 인증 시스템
```

## ✨ 주요 기능

### 1. 지원 카테고리 시스템
- **FAQ**: 자주 묻는 질문과 답변
- **버그 신고**: 게임 내 오류 신고
- **게임 가이드**: 플레이 도움말
- **실시간 채팅**: 상담원과 즉시 상담
- **이메일 문의**: 상세한 문의 전송
- **계정 지원**: 계정 관련 문제 해결

### 2. FAQ 시스템
- 조회수 기반 정렬
- 아코디언 형태의 접기/펼치기
- 카테고리별 분류 (gameplay, account, bug, general, payment)
- 실시간 조회수 업데이트

### 3. 문의 관리 시스템
- 문의 유형별 템플릿 자동완성
- 폼 유효성 검사
- 로그인 사용자 정보 자동입력
- 문의 내역 조회

### 4. 실시간 채팅
- 모달 기반 채팅 인터페이스
- 상담원 연결 시뮬레이션
- 메시지 타임스탬프
- 자동 응답 시스템

## 📁 상세 파일 분석

### customer-service.html

#### 메타 정보
```html
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>고객센터 - 게임 포털</title>
```

#### 의존성
- `styles.css`: 전체 스타일링
- `common-auth.js`: 사용자 인증
- `customer-service.js`: 고객센터 기능

#### 주요 HTML 구조

**1. 헤더 네비게이션**
```html
<header class="header">
    <div class="nav-container">
        <a href="index.html" class="logo">
            <span class="logo-icon">🎮</span>
            <span class="logo-text">GAME PORTAL</span>
        </a>
        <nav class="nav">
            <!-- 네비게이션 메뉴 -->
        </nav>
        <div class="auth-buttons" id="authButtons">
            <!-- 로그인/로그아웃 버튼 (동적 생성) -->
        </div>
    </div>
</header>
```

**2. 지원 카테고리 그리드**
```html
<div class="support-categories" id="supportCategories">
    <div class="support-card" data-category="faq">
        <div class="support-icon">❓</div>
        <h3>자주 묻는 질문</h3>
        <p>설명 텍스트</p>
    </div>
    <!-- 추가 카테고리들... -->
</div>
```

**3. FAQ 섹션**
```html
<div class="faq-section">
    <h3>❓ 자주 묻는 질문</h3>
    <div class="faq-list" id="faqList">
        <!-- JavaScript에서 동적으로 생성 -->
    </div>
</div>
```

**4. 문의 폼**
```html
<form id="inquiryForm">
    <div class="form-group">
        <label class="form-label" for="inquiryType">문의 유형</label>
        <select id="inquiryType" class="form-input" required>
            <option value="bug">버그 신고</option>
            <option value="account">계정 문제</option>
            <option value="payment">결제 관련</option>
            <option value="gameplay">게임플레이 문의</option>
            <option value="suggestion">건의사항</option>
            <option value="other">기타</option>
        </select>
    </div>
    <!-- 추가 필드들... -->
</form>
```

**5. 실시간 채팅 모달**
```html
<div id="chatModal" class="modal">
    <div class="modal-content chat-modal">
        <div class="modal-header">
            <h3>실시간 상담</h3>
            <div class="chat-status">
                <span class="status-indicator" id="chatStatus">연결 중...</span>
            </div>
        </div>
        <div class="modal-body">
            <div class="chat-messages" id="supportChatMessages">
                <!-- 채팅 메시지들 -->
            </div>
            <div class="chat-input-container">
                <input type="text" id="supportChatInput" placeholder="메시지를 입력하세요...">
                <button id="supportChatSend">전송</button>
            </div>
        </div>
    </div>
</div>
```

### customer-service.js

#### 전역 변수
```javascript
let currentUser = null;        // 현재 로그인 사용자
let chatConnected = false;     // 채팅 연결 상태
let faqData = [];             // FAQ 데이터
let userInquiries = [];       // 사용자 문의 내역
```

#### 기본 FAQ 데이터 구조
```javascript
const defaultFaqData = [
    {
        faq_id: 1,
        id: 1,                    // 기존 호환성
        question: "질문 내용",
        answer: "답변 내용",
        category: "gameplay",     // 카테고리
        views: 1250,             // 조회수
        is_active: true          // 활성 상태
    }
];
```

#### 핵심 함수들

**1. 페이지 초기화**
```javascript
function initializePage() {
    currentUser = getCurrentUser();
    setupEventListeners();
    loadFaqData();
    renderFaq();
    
    if (currentUser) {
        loadUserInquiries();
        document.getElementById('inquiryHistorySection').style.display = 'block';
    }
    
    setupFormAutofill();
}
```

**2. FAQ 데이터 로드**
```javascript
function loadFaqData() {
    try {
        fetch('/api/faq')
            .then(response => response.json())
            .then(serverFaqData => {
                faqData = serverFaqData.sort((a, b) => b.views - a.views);
                renderFaq();
            })
            .catch(error => {
                faqData = defaultFaqData.sort((a, b) => b.views - a.views);
            });
    } catch (error) {
        faqData = defaultFaqData.sort((a, b) => b.views - a.views);
    }
}
```

**3. FAQ 렌더링**
```javascript
function renderFaq() {
    const faqList = document.getElementById('faqList');
    faqList.innerHTML = faqData.map(faq => `
        <div class="faq-item" data-faq-id="${faq.faq_id || faq.id}">
            <button class="faq-question">
                <span>${escapeHtml(faq.question)}</span>
                <span class="faq-toggle">▼</span>
            </button>
            <div class="faq-answer">
                <p>${escapeHtml(faq.answer)}</p>
                <div class="faq-meta">
                    <span class="faq-views">조회수: ${faq.views}</span>
                </div>
            </div>
        </div>
    `).join('');
}
```

**4. 문의 제출**
```javascript
async function submitInquiry(e) {
    e.preventDefault();
    
    const formData = {
        user_id: currentUser ? currentUser.id : null,
        user_email: userEmailEl.value.trim(),
        inquiry_type: inquiryTypeEl.value,
        title: inquiryTitleEl.value.trim(),
        content: inquiryContentEl.value.trim(),
        game_info: gameInfoEl ? gameInfoEl.value.trim() : '',
        agreePrivacy: agreePrivacyEl.checked
    };
    
    if (!validateInquiryForm(formData)) return;
    
    try {
        const response = await fetch('/api/inquiries', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(formData)
        });
        
        if (response.ok) {
            showSuccessMessage();
            form.reset();
            if (currentUser) loadUserInquiries();
        }
    } catch (error) {
        alert('문의 전송 중 오류가 발생했습니다: ' + error.message);
    }
}
```

**5. 실시간 채팅**
```javascript
function openSupportChat() {
    if (!currentUser) {
        alert('로그인 후 실시간 채팅을 이용할 수 있습니다.');
        return;
    }
    
    const chatModal = document.getElementById('chatModal');
    chatModal.style.display = 'flex';
    
    // 상담원 연결 시뮬레이션
    setTimeout(() => {
        chatConnected = true;
        addChatMessage('agent', `안녕하세요 ${currentUser.nickname}님! 무엇을 도와드릴까요?`);
    }, 2000);
}

function sendChatMessage() {
    const message = chatInput.value.trim();
    if (!message || !chatConnected) return;
    
    addChatMessage('user', message);
    chatInput.value = '';
    
    // 자동 응답
    setTimeout(() => {
        const responses = [
            "네, 확인해보겠습니다. 잠시만 기다려주세요.",
            "해당 문제에 대해 도움을 드릴 수 있습니다."
        ];
        const randomResponse = responses[Math.floor(Math.random() * responses.length)];
        addChatMessage('agent', randomResponse);
    }, 1000 + Math.random() * 2000);
}
```

## 🛠️ 설치 및 설정

### 1. 기본 설정
```bash
# 파일 구조 생성
mkdir customer-service
cd customer-service

# 필요한 파일들 복사
cp customer-service.html ./
cp customer-service.js ./
cp styles.css ./
cp common-auth.js ./
```

### 2. 의존성 확인
- `common-auth.js`: 사용자 인증 시스템
- `styles.css`: 전체 스타일시트
- 백엔드 API 엔드포인트

### 3. API 엔드포인트
```javascript
// 필요한 API 엔드포인트들
GET  /api/faq                    // FAQ 목록 조회
POST /api/faq/{id}/view         // FAQ 조회수 증가
POST /api/inquiries             // 문의 등록
GET  /api/inquiries/user/{id}   // 사용자 문의 내역
```

## 🎯 사용 방법

### 1. 기본 사용법
```html
<!-- HTML 페이지에 스크립트 포함 -->
<script src="common-auth.js"></script>
<script src="customer-service.js" defer></script>
```

### 2. 커스터마이징

**FAQ 데이터 수정**
```javascript
// customer-service.js의 defaultFaqData 배열 수정
const defaultFaqData = [
    {
        faq_id: 1,
        question: "새로운 질문",
        answer: "새로운 답변",
        category: "새로운_카테고리",
        views: 0,
        is_active: true
    }
];
```

**문의 유형 추가**
```html
<!-- HTML의 select 옵션에 추가 -->
<option value="new_type">새로운 문의 유형</option>
```

```javascript
// JavaScript의 템플릿에 추가
const templates = {
    new_type: {
        title: '[새로운유형] ',
        content: '새로운 유형의 템플릿 내용'
    }
};
```

### 3. 이벤트 처리

**지원 카테고리 클릭**
```javascript
function handleSupportCategoryClick(category) {
    switch (category) {
        case 'custom_category':
            // 커스텀 동작 추가
            break;
    }
}
```

**폼 검증 규칙 수정**
```javascript
function validateInquiryForm(formData) {
    // 커스텀 검증 로직 추가
    if (customValidation(formData)) {
        return false;
    }
    return true;
}
```

## 🔧 API 연동

### 1. FAQ API
```javascript
// FAQ 조회
fetch('/api/faq')
    .then(response => response.json())
    .then(data => {
        // 서버 데이터 형식
        // [{faq_id, question, answer, category, views, is_active}]
    });

// FAQ 조회수 증가
fetch(`/api/faq/${faqId}/view`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'}
});
```

### 2. 문의 API
```javascript
// 문의 등록
const inquiryData = {
    user_id: 1,
    user_email: "user@example.com",
    inquiry_type: "bug",
    title: "문의 제목",
    content: "문의 내용",
    game_info: "추가 정보"
};

fetch('/api/inquiries', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(inquiryData)
});

// 사용자 문의 내역 조회
fetch(`/api/inquiries/user/${userId}`)
    .then(response => response.json())
    .then(data => {
        // [{id, title, content, type, status, created_at, response, response_date}]
    });
```

## 🎨 스타일링

### 1. CSS 클래스 구조
```css
/* 지원 카테고리 */
.support-categories { /* 그리드 컨테이너 */ }
.support-card { /* 개별 카드 */ }
.support-icon { /* 아이콘 */ }

/* FAQ */
.faq-section { /* FAQ 섹션 */ }
.faq-item { /* 개별 FAQ */ }
.faq-question { /* 질문 버튼 */ }
.faq-answer { /* 답변 영역 */ }

/* 폼 */
.form-group { /* 폼 그룹 */ }
.form-input { /* 입력 필드 */ }
.form-error { /* 에러 메시지 */ }

/* 채팅 */
.modal { /* 모달 배경 */ }
.chat-modal { /* 채팅 모달 */ }
.chat-messages { /* 메시지 영역 */ }
.chat-message { /* 개별 메시지 */ }
```

### 2. 반응형 디자인
```css
@media (max-width: 768px) {
    .support-categories {
        grid-template-columns: 1fr;
    }
    
    .chat-modal {
        width: 95%;
        height: 90%;
    }
}
```

## 🔒 보안 고려사항

### 1. XSS 방지
```javascript
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}
```

### 2. 사용자 입력 검증
```javascript
function validateInquiryForm(formData) {
    // 이메일 형식 검증
    if (!isValidEmail(formData.user_email)) {
        return false;
    }
    
    // 필수 필드 검증
    if (!formData.title || !formData.content) {
        return false;
    }
    
    return true;
}
```

### 3. 개인정보 보호
```javascript
// 개인정보 동의 확인
if (!formData.agreePrivacy) {
    showFieldError('agreePrivacy', '개인정보 수집 및 이용에 동의해주세요.');
    return false;
}
```

## 🐛 트러블슈팅

### 1. 일반적인 문제들

**FAQ가 로드되지 않는 경우**
```javascript
// 네트워크 오류 시 기본 데이터 사용
.catch(error => {
    console.error('FAQ 로드 실패:', error);
    faqData = defaultFaqData.sort((a, b) => b.views - a.views);
});
```

**폼 제출이 실패하는 경우**
```javascript
// 에러 처리 및 사용자 피드백
catch (error) {
    console.error('문의 전송 오류:', error);
    alert('문의 전송 중 오류가 발생했습니다: ' + error.message);
}
```

**채팅이 연결되지 않는 경우**
```javascript
// 로그인 상태 확인
if (!currentUser) {
    alert('로그인 후 실시간 채팅을 이용할 수 있습니다.');
    window.location.href = '/login';
    return;
}
```

### 2. 디버깅 팁

**콘솔 로그 활용**
```javascript
console.log('현재 사용자:', currentUser);
console.log('FAQ 데이터:', faqData);
console.log('폼 데이터:', formData);
```

**요소 존재 확인**
```javascript
const element = document.getElementById('elementId');
if (!element) {
    console.error('요소를 찾을 수 없습니다:', 'elementId');
    return;
}
```

## 📈 성능 최적화

### 1. 지연 로딩
```javascript
// 사용자가 로그인한 경우에만 문의 내역 로드
if (currentUser) {
    loadUserInquiries();
}
```

### 2. 에러 복구
```javascript
// 서버 오류 시 기본 데이터로 폴백
try {
    await serverCall();
} catch (error) {
    useDefaultData();
}
```

### 3. 메모리 관리
```javascript
// 이벤트 리스너 정리
function cleanup() {
    document.removeEventListener('scroll', scrollHandler);
}
```

## 📊 데이터 구조 상세

### 1. FAQ 데이터 스키마
```javascript
const faqStructure = {
    faq_id: Number,          // 고유 식별자
    id: Number,              // 기존 호환성용 ID
    question: String,        // 질문 내용
    answer: String,          // 답변 내용
    category: String,        // 카테고리 (gameplay, account, bug, general, payment)
    views: Number,           // 조회수
    is_active: Boolean       // 활성 상태
};
```

### 2. 문의 데이터 스키마
```javascript
const inquiryStructure = {
    id: Number,              // 문의 고유 ID
    user_id: Number,         // 사용자 ID (로그인시)
    user_email: String,      // 사용자 이메일
    inquiry_type: String,    // 문의 유형 (bug, account, payment, gameplay, suggestion, other)
    title: String,           // 문의 제목
    content: String,         // 문의 내용
    game_info: String,       // 게임 관련 정보 (선택사항)
    status: String,          // 상태 (pending, processing, resolved, closed)
    created_at: String,      // 생성일시 (ISO 8601)
    response: String,        // 답변 내용 (답변시에만)
    response_date: String,   // 답변일시 (답변시에만)
    agreePrivacy: Boolean    // 개인정보 동의 여부
};
```

### 3. 사용자 데이터 스키마
```javascript
const userStructure = {
    id: Number,              // 사용자 고유 ID
    nickname: String,        // 닉네임
    email: String,           // 이메일 주소
    // 기타 사용자 정보...
};
```

### 4. 채팅 메시지 구조
```javascript
const chatMessageStructure = {
    sender: String,          // 'user', 'agent', 'system'
    content: String,         // 메시지 내용
    timestamp: String,       // 메시지 시간
    messageId: String        // 메시지 고유 ID (확장시 사용)
};
```

## 🔄 라이프사이클 및 흐름

### 1. 페이지 로드 순서
```
1. DOMContentLoaded 이벤트 → initializePage() 호출
2. getCurrentUser() → 사용자 정보 확인
3. setupEventListeners() → 이벤트 리스너 등록
4. loadFaqData() → FAQ 데이터 로드 (비동기)
5. renderFaq() → FAQ 화면 렌더링
6. [로그인 사용자시] loadUserInquiries() → 문의 내역 로드
7. setupFormAutofill() → 폼 자동완성 설정
```

### 2. 문의 제출 프로세스
```
1. 사용자 폼 작성
2. inquiryType 변경시 → 템플릿 자동 적용
3. 폼 제출 → submitInquiry() 호출
4. validateInquiryForm() → 유효성 검사
5. 로딩 상태 표시
6. fetch('/api/inquiries') → 서버 전송
7. 성공시: showSuccessMessage() + 폼 리셋
8. 실패시: 에러 메시지 표시
9. 로딩 상태 해제
```

### 3. FAQ 상호작용 흐름
```
1. FAQ 질문 클릭
2. 모든 FAQ 아이템 비활성화
3. 클릭한 아이템 활성화 (토글)
4. increaseFaqViews() → 조회수 증가
5. 화면 조회수 업데이트
6. 서버에 조회수 전송 (백그라운드)
```

### 4. 실시간 채팅 흐름
```
1. 채팅 카드 클릭 → openSupportChat()
2. 로그인 확인 → 미로그인시 리다이렉트
3. 모달 표시 + 연결 중 상태
4. 2초 후 → 상담원 연결 시뮬레이션
5. 환영 메시지 표시
6. 사용자 메시지 입력 → sendChatMessage()
7. 사용자 메시지 표시
8. 1-3초 후 → 자동 응답 표시
```

## 🛡️ 에러 처리 및 복구 메커니즘

### 1. FAQ 로드 실패 처리
```javascript
// 3단계 폴백 시스템
1. 서버 API 호출 시도
2. 실패시 → defaultFaqData 사용
3. 에러 로깅 → 사용자 경험 유지
```

### 2. 문의 제출 실패 처리
```javascript
// 상세한 에러 피드백
try {
    // API 호출
} catch (error) {
    // 1. 사용자에게 에러 메시지 표시
    // 2. 콘솔에 상세 에러 로깅
    // 3. 폼 상태 복구 (로딩 해제)
}
```

### 3. DOM 요소 누락 방지
```javascript
// 모든 DOM 조작 전 요소 존재 확인
const element = document.getElementById('elementId');
if (!element) {
    console.error('요소를 찾을 수 없습니다:', 'elementId');
    return; // 조기 반환으로 에러 방지
}
```

### 4. 네트워크 에러 대응
```javascript
// 타임아웃 및 재시도 로직
const controller = new AbortController();
setTimeout(() => controller.abort(), 10000); // 10초 타임아웃

fetch('/api/endpoint', {
    signal: controller.signal
}).catch(error => {
    if (error.name === 'AbortError') {
        // 타임아웃 처리
    } else {
        // 네트워크 에러 처리
    }
});
```

## 📱 모바일 최적화 기능

### 1. 반응형 네비게이션
```javascript
// 모바일 햄버거 메뉴
const mobileToggle = document.getElementById('mobileToggle');
mobileToggle.addEventListener('click', function() {
    this.classList.toggle('active');
    navMenu.classList.toggle('active');
});
```

### 2. 터치 이벤트 지원
```javascript
// 모바일 터치 최적화
chatInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        sendChatMessage(); // 모바일에서 Enter키 지원
    }
});
```

### 3. 모달 모바일 최적화
```css
@media (max-width: 768px) {
    .chat-modal {
        width: 95%;
        height: 90%;
        margin: 5% auto;
    }
}
```

## ⚡ 성능 최적화 상세

### 1. 지연 로딩 전략
```javascript
// 로그인 사용자만 문의 내역 로드
if (currentUser) {
    loadUserInquiries(); // 조건부 로딩
}
```

### 2. 메모리 누수 방지
```javascript
// 모달 정리 함수
function closeSupportChat() {
    chatModal.style.display = 'none';
    document.body.style.overflow = 'auto';
    chatConnected = false; // 상태 초기화
}
```

### 3. DOM 조작 최적화
```javascript
// 일괄 DOM 업데이트
inquiryList.innerHTML = userInquiries.map(inquiry => `...`).join('');
// 개별 appendChild보다 효율적
```

### 4. 이벤트 위임 사용
```javascript
// FAQ 아이템에 이벤트 위임 적용
document.addEventListener('click', function(e) {
    if (e.target.matches('.faq-question')) {
        // FAQ 클릭 처리
    }
});
```

## 🌐 국제화 및 접근성

### 1. 언어 지원 준비
```javascript
// 다국어 지원을 위한 구조
const messages = {
    ko: {
        'inquiry.submit': '문의하기',
        'error.required': '필수 항목입니다'
    },
    en: {
        'inquiry.submit': 'Submit Inquiry',
        'error.required': 'This field is required'
    }
};
```

### 2. 접근성 기능
```html
<!-- 스크린 리더 지원 -->
<label for="userEmail">이메일 주소</label>
<input id="userEmail" type="email" required aria-describedby="userEmailError">
<span id="userEmailError" class="form-error" role="alert"></span>
```

### 3. 키보드 네비게이션
```javascript
// Tab 키 순서 관리
chatInput.addEventListener('keydown', function(e) {
    if (e.key === 'Tab' && e.shiftKey) {
        // Shift+Tab 처리
    }
});
```

## 🧪 테스트 가능한 기능들

### 1. 단위 테스트 대상 함수들
- `escapeHtml()`: XSS 방지 함수
- `isValidEmail()`: 이메일 검증
- `formatDate()`: 날짜 포맷팅
- `getStatusText()`: 상태 텍스트 변환
- `validateInquiryForm()`: 폼 검증

### 2. 통합 테스트 시나리오
- FAQ 로드 및 렌더링
- 문의 폼 제출 프로세스
- 실시간 채팅 플로우
- 모바일 반응형 동작

### 3. E2E 테스트 케이스
- 전체 문의 등록 과정
- FAQ 검색 및 조회
- 로그인/로그아웃 상태 변경
- 네트워크 에러 상황 처리

## 🚀 확장 가능성

### 1. 추가 기능 제안
- 파일 첨부 기능
- 음성 채팅 지원
- 다국어 지원
- 실시간 알림
- 티켓 시스템

### 2. 백엔드 연동 확장
```javascript
// WebSocket을 이용한 실시간 채팅
const socket = new WebSocket('ws://localhost:8080/chat');
socket.onmessage = function(event) {
    const message = JSON.parse(event.data);
    addChatMessage(message.sender, message.content);
};
```

### 3. 모듈화
```javascript
// 별도 모듈로 분리
import { ChatManager } from './modules/chat-manager.js';
import { FAQManager } from './modules/faq-manager.js';
import { InquiryManager } from './modules/inquiry-manager.js';
```

## 📝 변경 로그

### v1.0.0 (현재)
- 기본 고객센터 기능 구현
- FAQ 시스템
- 문의 폼
- 실시간 채팅 (시뮬레이션)
- 사용자 문의 내역

### 향후 버전 계획
- v1.1.0: 파일 첨부 기능
- v1.2.0: 실시간 채팅 백엔드 연동
- v1.3.0: 다국어 지원